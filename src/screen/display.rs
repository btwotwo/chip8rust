type Font = [u8; 80];

#[rustfmt::skip]
// credits to the http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#dispcoords
pub const FONT: Font = [
// ****
// *  *
// *  *
// *  *
// ****
0xF0,0x90,0x90,0x90,0xF0,
//   * 
//  ** 
//   * 
//   * 
//  ***
0x20,0x60,0x20,0x20,0x70,
// ****
//    *
// ****
// *   
// ****
0xF0,0x10,0xF0,0x80,0xF0,
// ****
//    *
// ****
//    *
// ****
0xF0,0x10,0xF0,0x10,0xF0,

// *  *
// *  *
// ****
//    *
//    *
0x90,0x90,0xF0,0x10,0x10,

// ****
// *   
// ****
//    *
// ****
0xF0,0x80,0xF0,0x10,0xF0,

// ****
// *   
// ****
// *  *
// ****
0xF0,0x80,0xF0,0x90,0xF0,

// ****
//    *
//   * 
//  *  
//  * 
0xF0,0x10,0x20,0x40,0x40,

// ****
// *  *
// ****
// *  *
// ****
0xF0,0x90,0xF0,0x90,0xF0,

// ****
// *  *
// ****
//    *
// ****
0xF0,0x90,0xF0,0x10,0xF0,

// ****
// *  *
// ****
// *  *
// *  *
0xF0,0x90,0xF0,0x90,0x90,

// *** 
// *  *
// *** 
// *  *
// *** 
0xE0,0x90,0xE0,0x90,0xE0,

// ****
// *   
// *   
// *   
// ****
0xF0,0x80,0x80,0x80,0xF0,

// *** 
// *  *
// *  *
// *  *
// ***
0xE0,0x90,0x90,0x90,0xE0,

// ****
// *   
// ****
// *   
// ****
0xF0,0x80,0xF0,0x80,0xF0,

// ****
// *   
// ****
// *   
// * 
0xF0,0x80,0xF0,0x80,0x80
];

type Row = u64;
#[derive(Debug)]
pub struct Display {
    pub contents: [Row; 32],
    pub should_redraw: bool,
}

impl Display {
    pub fn new() -> Self {
        Display {
            contents: [0; 32],
            should_redraw: false,
        }
    }

    pub fn draw(&mut self, x: u8, y: u8, sprites: &[&u8]) -> bool {
        self.should_redraw = true;
        let mut collision = false;

        for (row_idx, part) in sprites.iter().enumerate() {
            let row_idx = (row_idx + (y as usize)) % 32;
            let row = self.contents[row_idx];
            let part = u64::from(**part) << 56;
            let part = part.rotate_right(x.into());

            for pixel_idx in 0..63 {
                if collision {
                    break;
                }

                const MASK: u64 = 0x8000_0000_0000_0000;

                let row_pixel = (MASK >> pixel_idx) & row;
                let sprite_pixel = (MASK >> pixel_idx) & part;

                if row_pixel != 0 && sprite_pixel != 0 {
                    collision = true;
                }
            }

            self.contents[row_idx] = row ^ part
        }

        collision
    }

    pub fn clear(&mut self) {
        self.contents = [0; 32];
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn does_not_set_collision() {
        let mut disp = Display::new();

        disp.contents[0] = 0b_00001111;
        let sprite = vec![&0b_11110000];

        let col = disp.draw(0, 0, &sprite);

        assert_eq!(col, false);
    }

    #[test]
    fn sets_collision() {
        let mut disp = Display::new();

        disp.contents[0] = 0b_00001111 << 56;
        let sprite = vec![&0b_0000_1001];

        let col = disp.draw(0, 0, &sprite);

        assert_eq!(col, true);
    }

    #[test]
    fn y_moves_to_the_other_side() {
        let mut disp = Display::new();

        disp.contents[31] = 0b_0000_0000;

        let sprite = vec![&0b0000_1111, &0b0000_1111];

        disp.draw(0, 31, &sprite);

        println!("{:?}", disp);
        assert_eq!(disp.contents[0], 0b0000_1111 << 56);
    }

    #[test]
    fn prints_symbol() {
        let expected_screen: Vec<u64> = vec![
            //            0    4    8    12   16   20   24   28   32   36   40   44   48   52   56   60
            /*0*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*1*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*2*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*3*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*4*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*5*/
            0b0000_0000_0000_1111_1111_0000_0000_0000_1111_1111_0000_0000_0000_0000_0000_0000,
            /*6*/
            0b0000_0000_0000_1111_1111_0000_0000_0000_1111_1111_0000_0000_0000_0000_0000_0000,
            /*7*/
            0b0000_0000_0000_1111_1111_0000_0000_0000_1111_1111_0000_0000_0000_0000_0000_0000,
            /*8*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*9*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*10*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*11*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*12*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*13*/
            0b0000_0000_0000_1111_0000_0000_0000_0000_0000_1111_0000_0000_0000_0000_0000_0000,
            /*14*/
            0b0000_0000_0000_1111_0000_0000_0000_0000_0000_1111_0000_0000_0000_0000_0000_0000,
            /*15*/
            0b0000_0000_0000_1111_1111_1111_1111_1111_1111_1111_0000_0000_0000_0000_0000_0000,
            /*16*/
            0b0000_0000_0000_0000_0000_1111_1111_1111_0000_0000_0000_0000_0000_0000_0000_0000,
            /*17*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*18*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*19*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*20*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*21*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*22*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*23*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*24*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*25*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*26*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*27*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*28*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*29*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*30*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
            /*31*/
            0b0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000_0000,
        ];
    }
}
